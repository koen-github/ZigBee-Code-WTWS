###############################################################################
#
# IAR C/C++ Compiler V9.20.1.2476 for 8051                22/Feb/2017  14:31:39
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Users\koen\ZigBee-Code-WTWS\Components\hal\target\CC2530EB\hal_key.c
#    Command line       =  
#        -f
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00002000 -DZDAPP_CONFIG_PAN_ID=0xABCD
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={'H', 'O', 'G', 'E', 'S',
#        'C', 'H', 'O', 'O', 'L', 'U', 'T', 'R', 'E', 'C', 'H'}"
#        -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)
#        -DREJOIN_POLL_RATE=440
#        C:\Users\koen\ZigBee-Code-WTWS\Components\hal\target\CC2530EB\hal_key.c
#        -D HOLD_AUTO_START -D BUILD_ALL_DEVICES -D REFLECTOR -D NV_INIT -D
#        NV_RESTORE -D HAL_UART=TRUE -lC
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\CoordinatorEB\List\
#        -lA
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\CoordinatorEB\List\
#        --diag_suppress Pe001,Pa010,Pe1665 -o
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\CoordinatorEB\Obj\
#        -e --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        --core=plain --dptr=16,1 --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data_rom
#        --nr_virtual_regs 16 -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\
#        -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\Source\
#        -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\ZMain\TI2530DB\
#        -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\hal\include\
#        -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\
#        -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mac\include\
#        -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mac\high_level\
#        -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\
#        -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mt\
#        -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\osal\include\
#        -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\services\saddr\
#        -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\services\sdata\
#        -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\af\
#        -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\nwk\
#        -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\sapi\
#        -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\sec\
#        -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\sys\
#        -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\zdo\
#        -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\zmac\
#        -I
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\zmac\f8w\
#        -Ol --require_prototypes
#    List file          =  
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\CoordinatorEB\List\hal_key.lst
#    Object file        =  
#        C:\Users\koen\ZigBee-Code-WTWS\Projects\zstack\Samples\DemoApp\CC2530DB\CoordinatorEB\Obj\hal_key.r51
#
###############################################################################

C:\Users\koen\ZigBee-Code-WTWS\Components\hal\target\CC2530EB\hal_key.c
      1          /**************************************************************************************************
      2            Filename:       hal_key.c
      3            Revised:        $Date: 2010-09-15 19:02:45 -0700 (Wed, 15 Sep 2010) $
      4            Revision:       $Revision: 23815 $
      5          
      6            Description:    This file contains the interface to the HAL KEY Service.
      7          
      8          
      9            Copyright 2006-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          /*********************************************************************
     40           NOTE: If polling is used, the hal_driver task schedules the KeyRead()
     41                 to occur every 100ms.  This should be long enough to naturally
     42                 debounce the keys.  The KeyRead() function remembers the key
     43                 state of the previous poll and will only return a non-zero
     44                 value if the key state changes.
     45          
     46           NOTE: If interrupts are used, the KeyRead() function is scheduled
     47                 25ms after the interrupt occurs by the ISR.  This delay is used
     48                 for key debouncing.  The ISR disables any further Key interrupt
     49                 until KeyRead() is executed.  KeyRead() will re-enable Key
     50                 interrupts after executing.  Unlike polling, when interrupts
     51                 are enabled, the previous key state is not remembered.  This
     52                 means that KeyRead() will return the current state of the keys
     53                 (not a change in state of the keys).
     54          
     55           NOTE: If interrupts are used, the KeyRead() fucntion is scheduled by
     56                 the ISR.  Therefore, the joystick movements will only be detected
     57                 during a pushbutton interrupt caused by S1 or the center joystick
     58                 pushbutton.
     59          
     60           NOTE: When a switch like S1 is pushed, the S1 signal goes from a normally
     61                 high state to a low state.  This transition is typically clean.  The
     62                 duration of the low state is around 200ms.  When the signal returns
     63                 to the high state, there is a high likelihood of signal bounce, which
     64                 causes a unwanted interrupts.  Normally, we would set the interrupt
     65                 edge to falling edge to generate an interrupt when S1 is pushed, but
     66                 because of the signal bounce, it is better to set the edge to rising
     67                 edge to generate an interrupt when S1 is released.  The debounce logic
     68                 can then filter out the signal bounce.  The result is that we typically
     69                 get only 1 interrupt per button push.  This mechanism is not totally
     70                 foolproof because occasionally, signal bound occurs during the falling
     71                 edge as well.  A similar mechanism is used to handle the joystick
     72                 pushbutton on the DB.  For the EB, we do not have independent control
     73                 of the interrupt edge for the S1 and center joystick pushbutton.  As
     74                 a result, only one or the other pushbuttons work reasonably well with
     75                 interrupts.  The default is the make the S1 switch on the EB work more
     76                 reliably.
     77          
     78          *********************************************************************/
     79          
     80          /**************************************************************************************************
     81           *                                            INCLUDES
     82           **************************************************************************************************/
     83          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x89
   \   unsigned char volatile __sfr P0IFG
   \                     P0IFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8b
   \   unsigned char volatile __sfr P2IFG
   \                     P2IFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8c
   \   unsigned char volatile __sfr PICTL
   \                     PICTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa0
   \   union <unnamed> volatile __sfr _A_P2
   \                     _A_P2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xab
   \   unsigned char volatile __sfr P0IEN
   \                     P0IEN:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xac
   \   unsigned char volatile __sfr P2IEN
   \                     P2IEN:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc0
   \   union <unnamed> volatile __sfr _A_IRCON
   \                     _A_IRCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe8
   \   union <unnamed> volatile __sfr _A_IRCON2
   \                     _A_IRCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf5
   \   unsigned char volatile __sfr P2SEL
   \                     P2SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf7
   \   unsigned char volatile __sfr P2INP
   \                     P2INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xff
   \   unsigned char volatile __sfr P2DIR
   \                     P2DIR:
   \   000000                DS 1
     84          #include "hal_defs.h"
     85          #include "hal_types.h"
     86          #include "hal_board.h"
     87          #include "hal_drivers.h"
     88          #include "hal_adc.h"
     89          #include "hal_key.h"
     90          #include "osal.h"
     91          
     92          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
     93          
     94          /**************************************************************************************************
     95           *                                              MACROS
     96           **************************************************************************************************/
     97          
     98          /**************************************************************************************************
     99           *                                            CONSTANTS
    100           **************************************************************************************************/
    101          #define HAL_KEY_RISING_EDGE   0
    102          #define HAL_KEY_FALLING_EDGE  1
    103          
    104          #define HAL_KEY_DEBOUNCE_VALUE  25
    105          
    106          /* CPU port interrupt */
    107          #define HAL_KEY_CPU_PORT_0_IF P0IF
    108          #define HAL_KEY_CPU_PORT_2_IF P2IF
    109          
    110          /* SW_1 is at P0.1 */
    111          #define HAL_KEY_SW_1_PORT     P0
    112          #define HAL_KEY_SW_1_BIT      BV(1)
    113          #define HAL_KEY_SW_1_SEL      P0SEL
    114          #define HAL_KEY_SW_1_DIR      P0DIR
    115          #define HAL_KEY_SW_1_INP      P0INP
    116          
    117          /* edge interrupt */
    118          #define HAL_KEY_SW_1_EDGEBIT  BV(0)
    119          #define HAL_KEY_SW_1_EDGE     HAL_KEY_FALLING_EDGE
    120          
    121          /* SW_1 interrupts */
    122          #define HAL_KEY_SW_1_IEN      IEN1  /* CPU interrupt mask register */
    123          #define HAL_KEY_SW_1_IENBIT   BV(5) /* Mask bit for all of Port_0 */
    124          #define HAL_KEY_SW_1_ICTL     P0IEN /* Port Interrupt Control register */
    125          #define HAL_KEY_SW_1_ICTLBIT  BV(1) /* P0IEN - P0.1 enable/disable bit */
    126          #define HAL_KEY_SW_1_PXIFG    P0IFG /* Interrupt flag at source */
    127          
    128          /* SW_2 is at P2.0 */
    129          #define HAL_KEY_SW_2_PORT     P2
    130          #define HAL_KEY_SW_2_BIT      BV(0)
    131          #define HAL_KEY_SW_2_SEL      P2SEL
    132          #define HAL_KEY_SW_2_DIR      P2DIR
    133          #define HAL_KEY_SW_2_INP      P2INP
    134          
    135          /* edge interrupt */
    136          #define HAL_KEY_SW_2_EDGEBIT  BV(3)
    137          #define HAL_KEY_SW_2_EDGE     HAL_KEY_FALLING_EDGE
    138          
    139          /* SW_2 interrupts */
    140          #define HAL_KEY_SW_2_IEN      IEN2  /* CPU interrupt mask register */
    141          #define HAL_KEY_SW_2_IENBIT   BV(1) /* Mask bit for all of Port_2 */
    142          #define HAL_KEY_SW_2_ICTL     P2IEN /* Port Interrupt Control register */
    143          #define HAL_KEY_SW_2_ICTLBIT  BV(0) /* P2IEN - P2.0<->P2.3 enable/disable bit */
    144          #define HAL_KEY_SW_2_PXIFG    P2IFG /* Interrupt flag at source */
    145          
    146          /* Joy stick move at P2.0 */
    147          #define HAL_KEY_JOY_MOVE_PORT P2
    148          #define HAL_KEY_JOY_MOVE_BIT  BV(0)
    149          #define HAL_KEY_JOY_MOVE_SEL  P2SEL
    150          #define HAL_KEY_JOY_MOVE_DIR  P2DIR
    151          
    152          /* edge interrupt */
    153          #define HAL_KEY_JOY_MOVE_EDGEBIT  BV(3)
    154          #define HAL_KEY_JOY_MOVE_EDGE     HAL_KEY_FALLING_EDGE
    155          
    156          /* Joy move interrupts */
    157          #define HAL_KEY_JOY_MOVE_IEN      IEN2  /* CPU interrupt mask register */
    158          #define HAL_KEY_JOY_MOVE_IENBIT   BV(1) /* Mask bit for all of Port_2 */
    159          #define HAL_KEY_JOY_MOVE_ICTL     P2IEN /* Port Interrupt Control register */
    160          #define HAL_KEY_JOY_MOVE_ICTLBIT  BV(0) /* P2IENL - P2.0<->P2.3 enable/disable bit */
    161          #define HAL_KEY_JOY_MOVE_PXIFG    P2IFG /* Interrupt flag at source */
    162          
    163          #define HAL_KEY_JOY_CHN   HAL_ADC_CHANNEL_6
    164          
    165          /**************************************************************************************************
    166           *                                            TYPEDEFS
    167           **************************************************************************************************/
    168          
    169          
    170          /**************************************************************************************************
    171           *                                        GLOBAL VARIABLES
    172           **************************************************************************************************/

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    173          static uint8 halKeySavedKeys;     /* used to store previous key state in polling mode */
   \                     halKeySavedKeys:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    174          static halKeyCBack_t pHalKeyProcessFunction;
   \                     pHalKeyProcessFunction:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    175          static uint8 HalKeyConfigured;
   \                     HalKeyConfigured:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    176          bool Hal_KeyIntEnable;            /* interrupt enable/disable flag */
   \                     Hal_KeyIntEnable:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    177          
    178          /**************************************************************************************************
    179           *                                        FUNCTIONS - Local
    180           **************************************************************************************************/
    181          void halProcessKeyInterrupt(void);
    182          uint8 halGetJoyKeyInput(void);
    183          
    184          /**************************************************************************************************
    185           *                                        FUNCTIONS - API
    186           **************************************************************************************************/
    187          
    188          
    189          /**************************************************************************************************
    190           * @fn      HalKeyInit
    191           *
    192           * @brief   Initilize Key Service
    193           *
    194           * @param   none
    195           *
    196           * @return  None
    197           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    198          void HalKeyInit( void )
   \                     HalKeyInit:
    199          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    200            /* Initialize previous key to 0 */
    201            halKeySavedKeys = 0;
   \   000004   90....       MOV     DPTR,#halKeySavedKeys
   \   000007   7400         MOV     A,#0x0
   \   000009   F0           MOVX    @DPTR,A
    202          
    203            HAL_KEY_SW_1_SEL &= ~(HAL_KEY_SW_1_BIT);      /* Set pin function to GPIO */
   \   00000A   53F3FD       ANL     0xf3,#0xfd
    204            HAL_KEY_SW_1_DIR &= ~(HAL_KEY_SW_1_BIT);      /* Set pin direction to Input */
   \   00000D   53FDFD       ANL     0xfd,#0xfd
    205          
    206            HAL_KEY_SW_2_SEL &= ~(HAL_KEY_SW_2_BIT);      /* Set pin function to GPIO */
   \   000010   53F5FE       ANL     0xf5,#0xfe
    207            HAL_KEY_SW_2_DIR &= ~(HAL_KEY_SW_2_BIT);      /* Set pin direction to Input */
   \   000013   53FFFE       ANL     0xff,#0xfe
    208          
    209            HAL_KEY_SW_2_INP &= ~(HAL_KEY_SW_2_BIT);      /* 0 -> Pullup/pulldown */
   \   000016   53F7FE       ANL     0xf7,#0xfe
    210            HAL_KEY_SW_2_INP |= (BV(7));                  /* BIT7 = 1 -> Pulldown */
   \   000019   43F780       ORL     0xf7,#0x80
    211          
    212              /* Initialize callback function */
    213            pHalKeyProcessFunction  = NULL;
   \   00001C   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   00001F   7400         MOV     A,#0x0
   \   000021   F0           MOVX    @DPTR,A
   \   000022   A3           INC     DPTR
   \   000023   7400         MOV     A,#0x0
   \   000025   F0           MOVX    @DPTR,A
    214          
    215            /* Start with key is not configured */
    216            HalKeyConfigured = FALSE;
   \   000026   90....       MOV     DPTR,#HalKeyConfigured
   \   000029   7400         MOV     A,#0x0
   \   00002B   F0           MOVX    @DPTR,A
    217          }
   \   00002C   D083         POP     DPH
   \   00002E   D082         POP     DPL
   \   000030   02....       LJMP    ?BRET
   \   000033                REQUIRE P0SEL
   \   000033                REQUIRE P0DIR
   \   000033                REQUIRE P2SEL
   \   000033                REQUIRE P2DIR
   \   000033                REQUIRE P2INP
    218          
    219          /**************************************************************************************************
    220           * @fn      HalKeyConfig
    221           *
    222           * @brief   Configure the Key serivce
    223           *
    224           * @param   interruptEnable - TRUE/FALSE, enable/disable interrupt
    225           *          cback - pointer to the CallBack function
    226           *
    227           * @return  None
    228           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    229          void HalKeyConfig (bool interruptEnable, halKeyCBack_t cback)
   \                     HalKeyConfig:
    230          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    231            /* Enable/Disable Interrupt or */
    232            Hal_KeyIntEnable = interruptEnable;
   \   000007   EE           MOV     A,R6
   \   000008   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   00000B   F0           MOVX    @DPTR,A
    233          
    234            /* Register the callback fucntion */
    235            pHalKeyProcessFunction = cback;
   \   00000C   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
    236          
    237            /* Determine if interrupt is enable or not */
    238            if (Hal_KeyIntEnable)
   \   000014   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000017   E0           MOVX    A,@DPTR
   \   000018   6034         JZ      ??HalKeyConfig_0
    239            {
    240              /* Rising/Falling edge configuratinn */
    241          
    242              PICTL &= ~(HAL_KEY_SW_1_EDGEBIT);    /* Clear the edge bit */
   \   00001A   538CFE       ANL     0x8c,#0xfe
    243              /* For falling edge, the bit must be set. */
    244            #if (HAL_KEY_SW_1_EDGE == HAL_KEY_FALLING_EDGE)
    245              PICTL |= HAL_KEY_SW_1_EDGEBIT;
   \   00001D   438C01       ORL     0x8c,#0x1
    246            #endif
    247          
    248              /* Interrupt configuration:
    249               * - Enable interrupt generation at the port
    250               * - Enable CPU interrupt
    251               * - Clear any pending interrupt
    252               */
    253              HAL_KEY_SW_1_ICTL |= HAL_KEY_SW_1_ICTLBIT;
   \   000020   43AB02       ORL     0xab,#0x2
    254              HAL_KEY_SW_1_IEN |= HAL_KEY_SW_1_IENBIT;
   \   000023   D2BD         SETB    0xb8.5
    255              HAL_KEY_SW_1_PXIFG = ~(HAL_KEY_SW_1_BIT);
   \   000025   7589FD       MOV     0x89,#-0x3
    256          
    257              /* Rising/Falling edge configuratinn */
    258          
    259              HAL_KEY_JOY_MOVE_ICTL &= ~(HAL_KEY_JOY_MOVE_EDGEBIT);    /* Clear the edge bit */
   \   000028   53ACF7       ANL     0xac,#0xf7
    260              /* For falling edge, the bit must be set. */
    261            #if (HAL_KEY_JOY_MOVE_EDGE == HAL_KEY_FALLING_EDGE)
    262              HAL_KEY_JOY_MOVE_ICTL |= HAL_KEY_JOY_MOVE_EDGEBIT;
   \   00002B   43AC08       ORL     0xac,#0x8
    263            #endif
    264          
    265              /* Interrupt configuration:
    266               * - Enable interrupt generation at the port
    267               * - Enable CPU interrupt
    268               * - Clear any pending interrupt
    269               */
    270              HAL_KEY_JOY_MOVE_ICTL |= HAL_KEY_JOY_MOVE_ICTLBIT;
   \   00002E   43AC01       ORL     0xac,#0x1
    271              HAL_KEY_JOY_MOVE_IEN |= HAL_KEY_JOY_MOVE_IENBIT;
   \   000031   439A02       ORL     0x9a,#0x2
    272              HAL_KEY_JOY_MOVE_PXIFG = ~(HAL_KEY_JOY_MOVE_BIT);
   \   000034   758BFE       MOV     0x8b,#-0x2
    273          
    274              /* Do this only after the hal_key is configured - to work with sleep stuff */
    275              if (HalKeyConfigured == TRUE)
   \   000037   90....       MOV     DPTR,#HalKeyConfigured
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   6401         XRL     A,#0x1
   \   00003D   7027         JNZ     ??HalKeyConfig_1
    276              {
    277                osal_stop_timerEx(Hal_TaskID, HAL_KEY_EVENT);     /* Cancel polling if active */
   \   00003F                ; Setup parameters for call to function osal_stop_timerEx
   \   00003F   7A10         MOV     R2,#0x10
   \   000041   7B00         MOV     R3,#0x0
   \   000043   90....       MOV     DPTR,#Hal_TaskID
   \   000046   E0           MOVX    A,@DPTR
   \   000047   F9           MOV     R1,A
   \   000048   12....       LCALL   `??osal_stop_timerEx::?relay`; Banked call to: osal_stop_timerEx
   \   00004B   E9           MOV     A,R1
   \   00004C   8018         SJMP    ??HalKeyConfig_1
    278              }
    279            }
    280            else    /* Interrupts NOT enabled */
    281            {
    282              HAL_KEY_SW_1_ICTL &= ~(HAL_KEY_SW_1_ICTLBIT);       /* don't generate interrupt */
   \                     ??HalKeyConfig_0:
   \   00004E   53ABFD       ANL     0xab,#0xfd
    283              HAL_KEY_SW_1_IEN &= ~(HAL_KEY_SW_1_IENBIT);         /* Clear interrupt enable bit */
   \   000051   C2BD         CLR     0xb8.5
    284          
    285              HAL_KEY_SW_2_ICTL &= ~(HAL_KEY_SW_2_ICTLBIT);       /* don't generate interrupt */
   \   000053   53ACFE       ANL     0xac,#0xfe
    286              HAL_KEY_SW_2_IEN &= ~(HAL_KEY_SW_2_IENBIT);         /* Clear interrupt enable bit */
   \   000056   539AFD       ANL     0x9a,#0xfd
    287          
    288              osal_set_event(Hal_TaskID, HAL_KEY_EVENT);
   \   000059                ; Setup parameters for call to function osal_set_event
   \   000059   7A10         MOV     R2,#0x10
   \   00005B   7B00         MOV     R3,#0x0
   \   00005D   90....       MOV     DPTR,#Hal_TaskID
   \   000060   E0           MOVX    A,@DPTR
   \   000061   F9           MOV     R1,A
   \   000062   12....       LCALL   `??osal_set_event::?relay`; Banked call to: osal_set_event
   \   000065   E9           MOV     A,R1
    289            }
    290          
    291            /* Key now is configured */
    292            HalKeyConfigured = TRUE;
   \                     ??HalKeyConfig_1:
   \   000066   90....       MOV     DPTR,#HalKeyConfigured
   \   000069   7401         MOV     A,#0x1
   \   00006B   F0           MOVX    @DPTR,A
    293          }
   \   00006C   7F01         MOV     R7,#0x1
   \   00006E   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000071                REQUIRE PICTL
   \   000071                REQUIRE P0IEN
   \   000071                REQUIRE _A_IEN1
   \   000071                REQUIRE P0IFG
   \   000071                REQUIRE P2IEN
   \   000071                REQUIRE IEN2
   \   000071                REQUIRE P2IFG
    294          
    295          
    296          /**************************************************************************************************
    297           * @fn      HalKeyRead
    298           *
    299           * @brief   Read the current value of a key
    300           *
    301           * @param   None
    302           *
    303           * @return  keys - current keys status
    304           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    305          uint8 HalKeyRead ( void )
   \                     HalKeyRead:
    306          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    307            uint8 keys = 0;
   \   000000   7900         MOV     R1,#0x0
    308          
    309            if (HAL_PUSH_BUTTON1())
   \   000002   A281         MOV     C,0x80.1
   \   000004   4002         JC      ??HalKeyRead_0
    310            {
    311              keys = HAL_KEY_SW_1;
   \   000006   7901         MOV     R1,#0x1
    312            }
    313          
    314            if (HAL_PUSH_BUTTON2())
   \                     ??HalKeyRead_0:
   \   000008   A2A0         MOV     C,0xa0.0
   \   00000A   5005         JNC     ??HalKeyRead_1
    315            {
    316              keys |= HAL_KEY_SW_2;
   \   00000C   D3           SETB    C
   \   00000D   E9           MOV     A,R1
   \   00000E   92E1         MOV     0xE0 /* A   */.1,C
   \   000010   F9           MOV     R1,A
    317            }
    318          
    319            return keys;
   \                     ??HalKeyRead_1:
   \   000011   02....       LJMP    ?BRET
   \   000014                REQUIRE _A_P0
   \   000014                REQUIRE _A_P2
    320          }
    321          
    322          
    323          /**************************************************************************************************
    324           * @fn      HalKeyPoll
    325           *
    326           * @brief   Called by hal_driver to poll the keys
    327           *
    328           * @param   None
    329           *
    330           * @return  None
    331           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    332          void HalKeyPoll (void)
   \                     HalKeyPoll:
    333          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    334            uint8 keys = 0;
   \   000004   7900         MOV     R1,#0x0
    335          
    336            if (HAL_PUSH_BUTTON1())
   \   000006   A281         MOV     C,0x80.1
   \   000008   4002         JC      ??HalKeyPoll_0
    337            {
    338              keys = HAL_KEY_SW_1;
   \   00000A   7901         MOV     R1,#0x1
    339            }
    340          
    341            if (HAL_PUSH_BUTTON2())
   \                     ??HalKeyPoll_0:
   \   00000C   A2A0         MOV     C,0xa0.0
   \   00000E   5005         JNC     ??HalKeyPoll_1
    342            {
    343              keys |= HAL_KEY_SW_2;
   \   000010   D3           SETB    C
   \   000011   E9           MOV     A,R1
   \   000012   92E1         MOV     0xE0 /* A   */.1,C
   \   000014   F9           MOV     R1,A
    344            }
    345          
    346            /* If interrupts are not enabled, previous key status and current key status
    347             * are compared to find out if a key has changed status.
    348             */
    349            if (!Hal_KeyIntEnable)
   \                     ??HalKeyPoll_1:
   \   000015   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000018   E0           MOVX    A,@DPTR
   \   000019   700C         JNZ     ??HalKeyPoll_2
    350            {
    351              if (keys == halKeySavedKeys)
   \   00001B   90....       MOV     DPTR,#halKeySavedKeys
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   69           XRL     A,R1
   \   000020   6024         JZ      ??HalKeyPoll_3
    352              {
    353                /* Exit - since no keys have changed */
    354                return;
    355              }
    356              /* Store the current keys for comparation next time */
    357              halKeySavedKeys = keys;
   \   000022   E9           MOV     A,R1
   \   000023   90....       MOV     DPTR,#halKeySavedKeys
   \   000026   F0           MOVX    @DPTR,A
    358            }
    359            else
    360            {
    361              /* Key interrupt handled here */
    362            }
    363          
    364            /* Invoke Callback if new keys were depressed */
    365            if (keys && (pHalKeyProcessFunction))
   \                     ??HalKeyPoll_2:
   \   000027   E9           MOV     A,R1
   \   000028   601C         JZ      ??HalKeyPoll_3
   \   00002A   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   FA           MOV     R2,A
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   FB           MOV     R3,A
   \   000032   EA           MOV     A,R2
   \   000033   4B           ORL     A,R3
   \   000034   6010         JZ      ??HalKeyPoll_3
    366            {
    367              (pHalKeyProcessFunction) (keys, HAL_KEY_STATE_NORMAL);
   \   000036                ; Setup parameters for indirect call
   \   000036   7A00         MOV     R2,#0x0
   \   000038   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   F8           MOV     R0,A
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F583         MOV     DPH,A
   \   000041   8882         MOV     DPL,R0
   \   000043   12....       LCALL   ?CALL_IND
    368            }
    369          }
   \                     ??HalKeyPoll_3:
   \   000046   D083         POP     DPH
   \   000048   D082         POP     DPL
   \   00004A   02....       LJMP    ?BRET
   \   00004D                REQUIRE _A_P0
   \   00004D                REQUIRE _A_P2
    370          
    371          /**************************************************************************************************
    372           * @fn      halGetJoyKeyInput
    373           *
    374           * @brief   Map the ADC value to its corresponding key.
    375           *
    376           * @param   None
    377           *
    378           * @return  keys - current joy key status
    379           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    380          uint8 halGetJoyKeyInput(void)
   \                     halGetJoyKeyInput:
    381          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    382            /* The joystick control is encoded as an analog voltage.
    383             * Read the JOY_LEVEL analog value and map it to joy movement.
    384             */
    385            uint8 adc;
    386            uint8 ksave0 = 0;
   \   000005   7E00         MOV     R6,#0x0
    387            uint8 ksave1;
    388          
    389            /* Keep on reading the ADC until two consecutive key decisions are the same. */
    390            do
    391            {
    392              ksave1 = ksave0;    /* save previouse key reading */
   \                     ??halGetJoyKeyInput_0:
   \   000007   EE           MOV     A,R6
   \   000008   FF           MOV     R7,A
    393          
    394              adc = HalAdcRead (HAL_KEY_JOY_CHN, HAL_ADC_RESOLUTION_8);
   \   000009                ; Setup parameters for call to function HalAdcRead
   \   000009   7A01         MOV     R2,#0x1
   \   00000B   7906         MOV     R1,#0x6
   \   00000D   12....       LCALL   `??HalAdcRead::?relay`; Banked call to: HalAdcRead
   \   000010   EA           MOV     A,R2
   \   000011   F8           MOV     R0,A
    395          
    396              if ((adc >= 2) && (adc <= 38))
   \   000012   E8           MOV     A,R0
   \   000013   C3           CLR     C
   \   000014   9402         SUBB    A,#0x2
   \   000016   C3           CLR     C
   \   000017   9425         SUBB    A,#0x25
   \   000019   5007         JNC     ??halGetJoyKeyInput_1
    397              {
    398                 ksave0 |= HAL_KEY_UP;
   \   00001B   D3           SETB    C
   \   00001C   EE           MOV     A,R6
   \   00001D   92E0         MOV     0xE0 /* A   */.0,C
   \   00001F   FE           MOV     R6,A
   \   000020   803E         SJMP    ??halGetJoyKeyInput_2
    399              }
    400              else if ((adc >= 74) && (adc <= 88))
   \                     ??halGetJoyKeyInput_1:
   \   000022   E8           MOV     A,R0
   \   000023   C3           CLR     C
   \   000024   944A         SUBB    A,#0x4a
   \   000026   C3           CLR     C
   \   000027   940F         SUBB    A,#0xf
   \   000029   5007         JNC     ??halGetJoyKeyInput_3
    401              {
    402                ksave0 |= HAL_KEY_RIGHT;
   \   00002B   D3           SETB    C
   \   00002C   EE           MOV     A,R6
   \   00002D   92E1         MOV     0xE0 /* A   */.1,C
   \   00002F   FE           MOV     R6,A
   \   000030   802E         SJMP    ??halGetJoyKeyInput_2
    403              }
    404              else if ((adc >= 60) && (adc <= 73))
   \                     ??halGetJoyKeyInput_3:
   \   000032   E8           MOV     A,R0
   \   000033   C3           CLR     C
   \   000034   943C         SUBB    A,#0x3c
   \   000036   C3           CLR     C
   \   000037   940E         SUBB    A,#0xe
   \   000039   5007         JNC     ??halGetJoyKeyInput_4
    405              {
    406                ksave0 |= HAL_KEY_LEFT;
   \   00003B   D3           SETB    C
   \   00003C   EE           MOV     A,R6
   \   00003D   92E3         MOV     0xE0 /* A   */.3,C
   \   00003F   FE           MOV     R6,A
   \   000040   801E         SJMP    ??halGetJoyKeyInput_2
    407              }
    408              else if ((adc >= 39) && (adc <= 59))
   \                     ??halGetJoyKeyInput_4:
   \   000042   E8           MOV     A,R0
   \   000043   C3           CLR     C
   \   000044   9427         SUBB    A,#0x27
   \   000046   C3           CLR     C
   \   000047   9415         SUBB    A,#0x15
   \   000049   5007         JNC     ??halGetJoyKeyInput_5
    409              {
    410                ksave0 |= HAL_KEY_DOWN;
   \   00004B   D3           SETB    C
   \   00004C   EE           MOV     A,R6
   \   00004D   92E4         MOV     0xE0 /* A   */.4,C
   \   00004F   FE           MOV     R6,A
   \   000050   800E         SJMP    ??halGetJoyKeyInput_2
    411              }
    412              else if ((adc >= 89) && (adc <= 100))
   \                     ??halGetJoyKeyInput_5:
   \   000052   E8           MOV     A,R0
   \   000053   C3           CLR     C
   \   000054   9459         SUBB    A,#0x59
   \   000056   C3           CLR     C
   \   000057   940C         SUBB    A,#0xc
   \   000059   5005         JNC     ??halGetJoyKeyInput_2
    413              {
    414                ksave0 |= HAL_KEY_CENTER;
   \   00005B   D3           SETB    C
   \   00005C   EE           MOV     A,R6
   \   00005D   92E2         MOV     0xE0 /* A   */.2,C
   \   00005F   FE           MOV     R6,A
    415              }
    416            } while (ksave0 != ksave1);
   \                     ??halGetJoyKeyInput_2:
   \   000060   EF           MOV     A,R7
   \   000061   6E           XRL     A,R6
   \   000062   70A3         JNZ     ??halGetJoyKeyInput_0
    417          
    418            return ksave0;
   \   000064   EE           MOV     A,R6
   \   000065   F9           MOV     R1,A
   \   000066   7F01         MOV     R7,#0x1
   \   000068   02....       LJMP    ?BANKED_LEAVE_XDATA
    419          }
    420          
    421          /**************************************************************************************************
    422           * @fn      halProcessKeyInterrupt
    423           *
    424           * @brief   Checks to see if it's a valid key interrupt, saves interrupt driven key states for
    425           *          processing by HalKeyRead(), and debounces keys by scheduling HalKeyRead() 25ms later.
    426           *
    427           * @param
    428           *
    429           * @return
    430           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    431          void halProcessKeyInterrupt (void)
   \                     halProcessKeyInterrupt:
    432          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    433            bool valid=FALSE;
   \   000004   7800         MOV     R0,#0x0
    434          
    435            if (HAL_KEY_SW_1_PXIFG & HAL_KEY_SW_1_BIT)  /* Interrupt Flag has been set */
   \   000006   E589         MOV     A,0x89
   \   000008   A2E1         MOV     C,0xE0 /* A   */.1
   \   00000A   5005         JNC     ??halProcessKeyInterrupt_0
    436            {
    437              HAL_KEY_SW_1_PXIFG = ~(HAL_KEY_SW_1_BIT); /* Clear Interrupt Flag */
   \   00000C   7589FD       MOV     0x89,#-0x3
    438              valid = TRUE;
   \   00000F   7801         MOV     R0,#0x1
    439            }
    440          
    441            if (HAL_KEY_JOY_MOVE_PXIFG & HAL_KEY_JOY_MOVE_BIT)  /* Interrupt Flag has been set */
   \                     ??halProcessKeyInterrupt_0:
   \   000011   E58B         MOV     A,0x8b
   \   000013   A2E0         MOV     C,0xE0 /* A   */.0
   \   000015   5005         JNC     ??halProcessKeyInterrupt_1
    442            {
    443              HAL_KEY_JOY_MOVE_PXIFG = ~(HAL_KEY_JOY_MOVE_BIT); /* Clear Interrupt Flag */
   \   000017   758BFE       MOV     0x8b,#-0x2
    444              valid = TRUE;
   \   00001A   7801         MOV     R0,#0x1
    445            }
    446          
    447            if (valid)
   \                     ??halProcessKeyInterrupt_1:
   \   00001C   E8           MOV     A,R0
   \   00001D   6018         JZ      ??halProcessKeyInterrupt_2
    448            {
    449              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_DEBOUNCE_VALUE);
   \   00001F                ; Setup parameters for call to function osal_start_timerEx
   \   00001F   90....       MOV     DPTR,#__Constant_19
   \   000022   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   000025   7A10         MOV     R2,#0x10
   \   000027   7B00         MOV     R3,#0x0
   \   000029   90....       MOV     DPTR,#Hal_TaskID
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F9           MOV     R1,A
   \   00002E   12....       LCALL   `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   000031   7404         MOV     A,#0x4
   \   000033   12....       LCALL   ?DEALLOC_XSTACK8
   \   000036   E9           MOV     A,R1
    450            }
    451          }
   \                     ??halProcessKeyInterrupt_2:
   \   000037   D083         POP     DPH
   \   000039   D082         POP     DPL
   \   00003B   02....       LJMP    ?BRET
   \   00003E                REQUIRE P0IFG
   \   00003E                REQUIRE P2IFG
    452          
    453          /**************************************************************************************************
    454           * @fn      HalKeyEnterSleep
    455           *
    456           * @brief  - Get called to enter sleep mode
    457           *
    458           * @param
    459           *
    460           * @return
    461           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    462          void HalKeyEnterSleep ( void )
   \                     HalKeyEnterSleep:
    463          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    464          }
   \   000000   02....       LJMP    ?BRET
    465          
    466          /**************************************************************************************************
    467           * @fn      HalKeyExitSleep
    468           *
    469           * @brief   - Get called when sleep is over
    470           *
    471           * @param
    472           *
    473           * @return  - return saved keys
    474           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    475          uint8 HalKeyExitSleep ( void )
   \                     HalKeyExitSleep:
    476          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    477            /* Wake up and read keys */
    478            return ( HalKeyRead () );
   \   000004                ; Setup parameters for call to function HalKeyRead
   \   000004   12....       LCALL   `??HalKeyRead::?relay`; Banked call to: HalKeyRead
   \   000007   D083         POP     DPH
   \   000009   D082         POP     DPL
   \   00000B   02....       LJMP    ?BRET
    479          }
    480          
    481          /***************************************************************************************************
    482           *                                    INTERRUPT SERVICE ROUTINE
    483           ***************************************************************************************************/
    484          
    485          /**************************************************************************************************
    486           * @fn      halKeyPort0Isr
    487           *
    488           * @brief   Port0 ISR
    489           *
    490           * @param
    491           *
    492           * @return
    493           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    494          HAL_ISR_FUNCTION( halKeyPort0Isr, P0INT_VECTOR )
   \                     halKeyPort0Isr:
    495          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 14
   \   000007                ; Auto size: 0
    496            HAL_ENTER_ISR();
   \   000007   A2AF         MOV     C,0xa8.7
   \   000009   E4           CLR     A
   \   00000A   33           RLC     A
   \   00000B   FE           MOV     R6,A
   \   00000C   D2AF         SETB    0xa8.7
    497          
    498            if (HAL_KEY_SW_1_PXIFG & HAL_KEY_SW_1_BIT)
   \   00000E   E589         MOV     A,0x89
   \   000010   A2E1         MOV     C,0xE0 /* A   */.1
   \   000012   5003         JNC     ??halKeyPort0Isr_0
    499            {
    500              halProcessKeyInterrupt();
   \   000014                ; Setup parameters for call to function halProcessKeyInterrupt
   \   000014   12....       LCALL   `??halProcessKeyInterrupt::?relay`; Banked call to: halProcessKeyInterrupt
    501            }
    502          
    503            /*
    504              Clear the CPU interrupt flag for Port_0
    505              PxIFG has to be cleared before PxIF
    506            */
    507            HAL_KEY_SW_1_PXIFG = 0;
   \                     ??halKeyPort0Isr_0:
   \   000017   758900       MOV     0x89,#0x0
    508            HAL_KEY_CPU_PORT_0_IF = 0;
   \   00001A   C2C5         CLR     0xc0.5
    509          
    510            CLEAR_SLEEP_MODE();
    511            HAL_EXIT_ISR();
   \   00001C   EE           MOV     A,R6
   \   00001D   F8           MOV     R0,A
   \   00001E   EE           MOV     A,R6
   \   00001F   A2E0         MOV     C,0xE0 /* A   */.0
   \   000021   92AF         MOV     0xa8.7,C
    512          }
   \   000023   7F01         MOV     R7,#0x1
   \   000025   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   000028                REQUIRE _A_IEN0
   \   000028                REQUIRE P0IFG
   \   000028                REQUIRE _A_IRCON
    513          
    514          
    515          /**************************************************************************************************
    516           * @fn      halKeyPort2Isr
    517           *
    518           * @brief   Port2 ISR
    519           *
    520           * @param
    521           *
    522           * @return
    523           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    524          HAL_ISR_FUNCTION( halKeyPort2Isr, P2INT_VECTOR )
   \                     halKeyPort2Isr:
    525          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 14
   \   000007                ; Auto size: 0
    526            HAL_ENTER_ISR();
   \   000007   A2AF         MOV     C,0xa8.7
   \   000009   E4           CLR     A
   \   00000A   33           RLC     A
   \   00000B   FE           MOV     R6,A
   \   00000C   D2AF         SETB    0xa8.7
    527          
    528            if (HAL_KEY_JOY_MOVE_PXIFG & HAL_KEY_JOY_MOVE_BIT)
   \   00000E   E58B         MOV     A,0x8b
   \   000010   A2E0         MOV     C,0xE0 /* A   */.0
   \   000012   5003         JNC     ??halKeyPort2Isr_0
    529            {
    530              halProcessKeyInterrupt();
   \   000014                ; Setup parameters for call to function halProcessKeyInterrupt
   \   000014   12....       LCALL   `??halProcessKeyInterrupt::?relay`; Banked call to: halProcessKeyInterrupt
    531            }
    532          
    533            /*
    534              Clear the CPU interrupt flag for Port_2
    535              PxIFG has to be cleared before PxIF
    536              Notes: P2_1 and P2_2 are debug lines.
    537            */
    538            HAL_KEY_JOY_MOVE_PXIFG = 0;
   \                     ??halKeyPort2Isr_0:
   \   000017   758B00       MOV     0x8b,#0x0
    539            HAL_KEY_CPU_PORT_2_IF = 0;
   \   00001A   C2E8         CLR     0xe8.0
    540          
    541            CLEAR_SLEEP_MODE();
    542            HAL_EXIT_ISR();
   \   00001C   EE           MOV     A,R6
   \   00001D   F8           MOV     R0,A
   \   00001E   EE           MOV     A,R6
   \   00001F   A2E0         MOV     C,0xE0 /* A   */.0
   \   000021   92AF         MOV     0xa8.7,C
    543          }
   \   000023   7F01         MOV     R7,#0x1
   \   000025   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   000028                REQUIRE _A_IEN0
   \   000028                REQUIRE P2IFG
   \   000028                REQUIRE _A_IRCON2

   \                                 In  segment INTVEC, offset 0x33, root
   \                     `??halKeyPort2Isr::??INTVEC 51`:
   \   000033   02....       LJMP       (halKeyPort2Isr)

   \                                 In  segment INTVEC, offset 0x6b, root
   \                     `??halKeyPort0Isr::??INTVEC 107`:
   \   00006B   02....       LJMP       (halKeyPort0Isr)

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_19:
   \   000000   19000000     DD 25

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalKeyConfig::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalKeyRead::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalKeyPoll::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyPoll

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??halGetJoyKeyInput::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halGetJoyKeyInput

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??halProcessKeyInterrupt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halProcessKeyInterrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalKeyEnterSleep::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyEnterSleep

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalKeyExitSleep::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyExitSleep
    544          
    545          #else
    546          
    547          void HalKeyInit(void){}
    548          void HalKeyConfig(bool interruptEnable, halKeyCBack_t cback){}
    549          uint8 HalKeyRead(void){ return 0;}
    550          void HalKeyPoll(void){}
    551          
    552          #endif /* HAL_KEY */
    553          
    554          
    555          
    556          
    557          
    558          /**************************************************************************************************
    559          **************************************************************************************************/
    560          
    561          
    562          

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0      9   HalKeyConfig
        0      9   -> osal_set_event
        0      9   -> osal_stop_timerEx
      0      0   HalKeyEnterSleep
      2      0   HalKeyExitSleep
        2      0   -> HalKeyRead
      2      0   HalKeyInit
      2      0   HalKeyPoll
      0      0   HalKeyRead
      0      9   halGetJoyKeyInput
        0      9   -> HalAdcRead
      0     14   halKeyPort0Isr
        0     14   -> halProcessKeyInterrupt
      0     14   halKeyPort2Isr
        0     14   -> halProcessKeyInterrupt
      2     18   halProcessKeyInterrupt
        2      4   -> osal_start_timerEx


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
     113  HalKeyConfig
       6  HalKeyConfig::?relay
       1  HalKeyConfigured
       3  HalKeyEnterSleep
       6  HalKeyEnterSleep::?relay
      14  HalKeyExitSleep
       6  HalKeyExitSleep::?relay
      51  HalKeyInit
       6  HalKeyInit::?relay
      77  HalKeyPoll
       6  HalKeyPoll::?relay
      20  HalKeyRead
       6  HalKeyRead::?relay
       1  Hal_KeyIntEnable
       1  IEN2
       1  P0DIR
       1  P0IEN
       1  P0IFG
       1  P0SEL
       1  P2DIR
       1  P2IEN
       1  P2IFG
       1  P2INP
       1  P2SEL
       1  PICTL
       1  _A_IEN0
       1  _A_IEN1
       1  _A_IRCON
       1  _A_IRCON2
       1  _A_P0
       1  _A_P2
       4  __Constant_19
     107  halGetJoyKeyInput
       6  halGetJoyKeyInput::?relay
      40  halKeyPort0Isr
       3  halKeyPort0Isr::??INTVEC 107
      40  halKeyPort2Isr
       3  halKeyPort2Isr::??INTVEC 51
       1  halKeySavedKeys
      62  halProcessKeyInterrupt
       6  halProcessKeyInterrupt::?relay
       2  pHalKeyProcessFunction

 
 447 bytes in segment BANKED_CODE
  48 bytes in segment BANK_RELAYS
   6 bytes in segment INTVEC
  80 bytes in segment NEAR_CODE
  17 bytes in segment SFR_AN
   4 bytes in segment XDATA_ROM_C
   5 bytes in segment XDATA_Z
 
 575 bytes of CODE  memory (+  6 bytes shared)
   0 bytes of CONST memory (+  4 bytes shared)
   0 bytes of DATA  memory (+ 17 bytes shared)
   5 bytes of XDATA memory

Errors: none
Warnings: none
